<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Relativity: Electric & Magnetic Fields of a Moving Charge</title>
  <style>
    :root{
      --bg:#0b0e14;
      --panel:#121826;
      --text:#e6e9ef;
      --muted:#aab2c0;
      --blue:#4aa3ff;
      --orange:#ffb020;
      --grid:#1f2a3d;
      --line:#26324a;
      --good:#61d67a;
    }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background:var(--bg);
      color:var(--text);
    }
    .wrap{
      max-width:1200px;
      margin:0 auto;
      padding:16px;
    }
    h1{
      font-size:20px;
      margin:0 0 8px 0;
      font-weight:650;
      letter-spacing:.2px;
    }
    .sub{
      color:var(--muted);
      line-height:1.35;
      margin-bottom:12px;
      font-size:13px;
    }
    .row{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
    }
    .card{
      background:var(--panel);
      border:1px solid var(--line);
      border-radius:12px;
      padding:12px;
      flex:1 1 520px;
      min-width:320px;
    }
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px 14px;
      align-items:center;
      margin-bottom:10px;
    }
    .control{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    label{
      font-size:12px;
      color:var(--muted);
      display:flex;
      justify-content:space-between;
      gap:8px;
    }
    input[type="range"]{
      width:100%;
    }
    .toggles{
      display:flex;
      gap:14px;
      align-items:center;
      flex-wrap:wrap;
      margin-top:4px;
    }
    .toggles label{
      display:flex;
      align-items:center;
      gap:8px;
      justify-content:flex-start;
      color:var(--text);
      font-size:12px;
    }
    .canvas-wrap{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    canvas{
      width:100%;
      height:420px;
      background: #0a0f1a;
      border:1px solid var(--line);
      border-radius:12px;
    }
    .legend{
      display:flex;
      gap:14px;
      align-items:center;
      flex-wrap:wrap;
      margin-top:8px;
      color:var(--muted);
      font-size:12px;
    }
    .swatch{
      display:inline-block;
      width:12px;height:12px;border-radius:3px;
      margin-right:6px;
      vertical-align:-2px;
    }
    .dot{
      display:inline-block;
      width:12px;height:12px;border-radius:50%;
      margin-right:6px;
      vertical-align:-2px;
      border:1px solid rgba(255,255,255,.18);
    }
    .readout{
      margin-top:10px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:8px 12px;
      font-size:12px;
      color:var(--muted);
    }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; color: var(--text); }
    .hint{
      margin-top:10px;
      font-size:12px;
      color:var(--muted);
      line-height:1.35;
    }
    .ok{ color: var(--good); }
    @media (max-width: 900px){
      .canvas-wrap{ grid-template-columns:1fr; }
      .readout{ grid-template-columns:1fr; }
      canvas{ height:380px; }
    }

    /* Styles for the 3D visualization canvas */
    #c3d {
      width: 100%;
      height: 460px;
      background: #0a0f1a;
      border: 1px solid var(--line);
      border-radius: 12px;
      display: block;
      margin-top: 12px;
    }
  </style>

  <!-- Import Three.js and OrbitControls for the 3D visualization. Using specific versions via CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/examples/js/controls/OrbitControls.min.js"></script>
</head>
<body>
  <div class="wrap">
    <h1>Electric & Magnetic Fields: “Same thing”, different frames</h1>
    <div class="sub">
      Left panel = lab frame. Right panel = an observer moving at speed β<sub>obs</sub> along x. A moving charge generates E and B;
      a Lorentz boost mixes them. This is the concrete version of what you were asking.
    </div>

    <div class="card">
      <div class="controls">
        <div class="control">
          <label>
            <span>Charge speed β = v/c</span>
            <span class="mono" id="betaTxt"></span>
          </label>
          <input id="beta" type="range" min="-0.95" max="0.95" step="0.01" value="0.60"/>
        </div>

        <div class="control">
          <label>
            <span>Observer speed β<sub>obs</sub> (boost along x)</span>
            <span class="mono" id="bObsTxt"></span>
          </label>
          <input id="bObs" type="range" min="-0.95" max="0.95" step="0.01" value="0.00"/>
        </div>

        <div class="control">
          <label>
            <span>Field arrow density</span>
            <span class="mono" id="densTxt"></span>
          </label>
          <input id="density" type="range" min="10" max="28" step="1" value="18"/>
        </div>

        <div class="control">
          <label>
            <span>Arrow scaling (visual only)</span>
            <span class="mono" id="scaleTxt"></span>
          </label>
          <input id="scale" type="range" min="0.6" max="2.0" step="0.05" value="1.1"/>
        </div>
      </div>

      <div class="toggles">
        <label><input id="showE" type="checkbox" checked> Show E vectors (blue)</label>
        <label><input id="showB" type="checkbox" checked> Show B (out-of-page dots)</label>
        <label><input id="showGrid" type="checkbox" checked> Show grid</label>
        <label><input id="animate" type="checkbox" checked> Animate charge motion</label>
      </div>

      <div class="canvas-wrap" style="margin-top:10px;">
        <div>
          <div class="sub" style="margin:6px 0 8px 4px;">Lab frame: fields around a charge moving at β</div>
          <canvas id="cLab" width="900" height="520"></canvas>
        </div>
        <div>
          <div class="sub" style="margin:6px 0 8px 4px;">Observer frame: boosted by β<sub>obs</sub> (E,B mix)</div>
          <canvas id="cObs" width="900" height="520"></canvas>
        </div>
      </div>

      <div class="legend">
        <span><span class="swatch" style="background:var(--blue)"></span>E field vectors</span>
        <span><span class="dot" style="background:var(--orange)"></span>B out of page: ⊘ (positive), ⊗ (negative)</span>
        <span class="ok">Probe point is draggable (green). Compare E,B vs E’,B’ numerically.</span>
      </div>

      <div class="readout">
        <div>Probe position (x,y): <span class="mono" id="pTxt"></span></div>
        <div>Charge position (x,y): <span class="mono" id="qTxt"></span></div>
        <div>Lab: |E|, Bz: <span class="mono" id="labTxt"></span></div>
        <div>Observer: |E’|, Bz’: <span class="mono" id="obsTxt"></span></div>
      </div>

      <div class="hint">
        What to look for: increase |β| and the E field “pancakes” sideways (stronger perpendicular to motion).
        B appears automatically from motion (not a separate knob). Now move β<sub>obs</sub>:
        the observer frame mixes E and B. At β<sub>obs</sub> ≈ β, the charge is nearly at rest and B’ tends toward zero.
      </div>

      <!-- 3D visualization of the fields at the probe position -->
      <div class="sub" style="margin:10px 0 6px 4px;">3D view at probe: lab (blue/orange) vs observer (green/orange)</div>
      <canvas id="c3d" width="900" height="460"></canvas>
    </div>
  </div>

<script>
(() => {
  // Units: set c = 1, k*q = 1 for display. We visualize a 2D slice (x-y plane).
  // Charge moves along x. Magnetic field is out-of-plane (Bz).

  const cLab = document.getElementById("cLab");
  const cObs = document.getElementById("cObs");
  const ctxL = cLab.getContext("2d");
  const ctxO = cObs.getContext("2d");

  // --- 3D visualization setup ---
  // A WebGL canvas (c3d) is used to visualize the E and B vectors at the probe point
  // in three dimensions. We import Three.js and OrbitControls in the page head. The
  // scene contains four arrows: two for the lab frame (E and B) and two for the
  // observer frame. B arrows always point along ±z (out of plane); E arrows lie
  // in the x–y plane. The arrow lengths are proportional to field strength.
  const c3dEl = document.getElementById("c3d");
  let renderer3D, scene3D, camera3D, controls3D;
  let eLabArrow3D, bLabArrow3D, eObsArrow3D, bObsArrow3D;
  if (c3dEl && typeof THREE !== 'undefined') {
    scene3D = new THREE.Scene();
    const width3D  = c3dEl.clientWidth;
    const height3D = c3dEl.clientHeight;
    camera3D = new THREE.PerspectiveCamera(45, width3D / height3D, 0.1, 100);
    camera3D.position.set(3.5, 3.0, 3.5);
    scene3D.add(new THREE.AxesHelper(1.5));
    renderer3D = new THREE.WebGLRenderer({ canvas: c3dEl, antialias: true, alpha: true });
    renderer3D.setSize(width3D, height3D);
    controls3D = new THREE.OrbitControls(camera3D, renderer3D.domElement);
    controls3D.enableDamping = true;
    controls3D.dampingFactor = 0.12;
    controls3D.rotateSpeed = 0.6;

    const origin3D = new THREE.Vector3(0, 0, 0);
    // Colours from CSS variables converted to hex
    const blueHex   = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--blue').trim().replace('#',''), 16);
    const orangeHex = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--orange').trim().replace('#',''), 16);
    const greenHex  = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--good').trim().replace('#',''), 16);

    // Initialize the arrows with tiny length; direction will be updated each frame
    eLabArrow3D = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), origin3D, 0.001, blueHex);
    bLabArrow3D = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), origin3D, 0.001, orangeHex);
    eObsArrow3D = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), origin3D, 0.001, greenHex);
    bObsArrow3D = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), origin3D, 0.001, orangeHex);
    scene3D.add(eLabArrow3D);
    scene3D.add(bLabArrow3D);
    scene3D.add(eObsArrow3D);
    scene3D.add(bObsArrow3D);
  }

  const betaEl = document.getElementById("beta");
  const bObsEl = document.getElementById("bObs");
  const densEl = document.getElementById("density");
  const scaleEl = document.getElementById("scale");
  const showEEl = document.getElementById("showE");
  const showBEl = document.getElementById("showB");
  const showGridEl = document.getElementById("showGrid");
  const animEl = document.getElementById("animate");

  const betaTxt = document.getElementById("betaTxt");
  const bObsTxt = document.getElementById("bObsTxt");
  const densTxt = document.getElementById("densTxt");
  const scaleTxt = document.getElementById("scaleTxt");

  const pTxt = document.getElementById("pTxt");
  const qTxt = document.getElementById("qTxt");
  const labTxt = document.getElementById("labTxt");
  const obsTxt = document.getElementById("obsTxt");

  // World coordinates mapped to canvas.
  // World box: x ∈ [-3, 3], y ∈ [-2, 2]
  const world = { xmin:-3, xmax:3, ymin:-2, ymax:2 };

  function gamma(beta){ return 1 / Math.sqrt(1 - beta*beta); }

  function w2c(canvas, x, y){
    const W = canvas.width, H = canvas.height;
    const u = (x - world.xmin)/(world.xmax - world.xmin);
    const v = (y - world.ymin)/(world.ymax - world.ymin);
    return { X: u*W, Y: (1-v)*H };
  }
  function c2w(canvas, X, Y){
    const W = canvas.width, H = canvas.height;
    const u = X/W;
    const v = 1 - (Y/H);
    return {
      x: world.xmin + u*(world.xmax - world.xmin),
      y: world.ymin + v*(world.ymax - world.ymin)
    };
  }

  // Probe point (draggable)
  let probe = { x: 1.2, y: 0.8 };
  let dragging = false;
  function attachDrag(canvas){
    canvas.addEventListener("pointerdown", (e)=>{
      const r = canvas.getBoundingClientRect();
      const X = (e.clientX - r.left) * (canvas.width / r.width);
      const Y = (e.clientY - r.top) * (canvas.height / r.height);
      const w = c2w(canvas, X, Y);
      const dx = w.x - probe.x, dy = w.y - probe.y;
      if (dx*dx + dy*dy < 0.08*0.08){ dragging = true; canvas.setPointerCapture(e.pointerId); }
    });
    canvas.addEventListener("pointermove", (e)=>{
      if (!dragging) return;
      const r = canvas.getBoundingClientRect();
      const X = (e.clientX - r.left) * (canvas.width / r.width);
      const Y = (e.clientY - r.top) * (canvas.height / r.height);
      const w = c2w(canvas, X, Y);
      probe.x = Math.max(world.xmin, Math.min(world.xmax, w.x));
      probe.y = Math.max(world.ymin, Math.min(world.ymax, w.y));
    });
    canvas.addEventListener("pointerup", ()=> dragging=false);
    canvas.addEventListener("pointercancel", ()=> dragging=false);
  }
  attachDrag(cLab);
  attachDrag(cObs);

  // Field of a uniformly moving charge in lab frame (constant velocity along x).
  // Using known closed form:
  // E = (1 - β^2) * r / [ (r^2 - (β×r)^2)^(3/2) ]  (in c=1, kq=1)
  // For motion along x, this becomes: E_x = (1-β^2) * x / D^(3/2), E_y = (1-β^2) * y / D^(3/2)
  // where D = x^2 + (1-β^2)*y^2  (equivalent form; gives the "pancake" effect)
  // B = β × E  -> Bz = β * Ey (since v along +x, v×E points ±z, and Ex doesn't contribute)
  // NOTE: This is qualitative & correct for constant velocity; ignores radiation (requires acceleration).
  function fieldsLabAtPoint(beta, qpos, x, y){
    const rx = x - qpos.x;
    const ry = y - qpos.y;

    const b2 = beta*beta;
    const eps = 1e-4;

    const D = (rx*rx + (1 - b2)*ry*ry) + eps;
    const coeff = (1 - b2) / Math.pow(D, 1.5);

    const Ex = coeff * rx;
    const Ey = coeff * ry;

    // Bz = (v × E)_z ; v = (beta,0,0); E=(Ex,Ey,0) => v×E = (0,0,beta*Ey)
    const Bz = beta * Ey;

    return { Ex, Ey, Bz };
  }

  // Lorentz transform of E,B for boost along x with speed u = betaObs (c=1)
  // E_parallel' = E_parallel
  // E_perp' = γ (E_perp + u × B)  (careful with sign conventions; here u is boost velocity of new frame relative old)
  // B_parallel' = B_parallel
  // B_perp' = γ (B_perp - u × E)
  //
  // With boost along x: u=(u,0,0). Fields in our slice: E=(Ex,Ey,0), B=(0,0,Bz)
  // u×B = (u,0,0)×(0,0,Bz) = (0, -u*Bz, 0)
  // u×E = (u,0,0)×(Ex,Ey,0) = (0,0,u*Ey)
  //
  // So:
  // Ex' = Ex
  // Ey' = γ (Ey + (u×B)_y) = γ (Ey - u*Bz)
  // Bz' = γ (Bz - (u×E)_z) = γ (Bz - u*Ey)
  function boostAlongX(betaObs, Ex, Ey, Bz){
    const g = gamma(betaObs);
    const ExP = Ex;
    const EyP = g * (Ey - betaObs * Bz);
    const BzP = g * (Bz - betaObs * Ey);
    return { Ex: ExP, Ey: EyP, Bz: BzP };
  }

  function drawGrid(ctx, canvas){
    const W=canvas.width, H=canvas.height;
    ctx.save();
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid').trim();
    ctx.lineWidth = 1;
    ctx.globalAlpha = 0.6;
    const nx=12, ny=8;
    for(let i=1;i<nx;i++){
      const x=i*W/nx;
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
    }
    for(let j=1;j<ny;j++){
      const y=j*H/ny;
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
    }
    ctx.restore();
  }

  function arrow(ctx, x, y, vx, vy, color){
    const len = Math.hypot(vx, vy);
    // Skip if the vector is essentially zero
    if (len < 1e-6) return;
    // Unit direction of the vector
    const ux = vx / len, uy = vy / len;

    ctx.save();
    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    // Further thicken the arrow lines to improve visibility on high resolution displays
    // Further increase the line width for arrows so they remain prominent on
    // high‑resolution displays. The extra thickness helps differentiate
    // vectors from small dots and the grid.
    ctx.lineWidth = 4;
    ctx.globalAlpha = 0.9;

    // Determine arrow length with minimum and maximum limits.
    // This prevents very small field vectors from rendering as tiny points and
    // keeps large vectors from having excessively long arrows. Increase the
    // minimum and maximum to make small arrows more visible.
    // Increase minimum and maximum arrow lengths to make arrows much more visible
    // even when the scaled field vector is small. This ensures vectors don't
    // collapse into tiny points on the canvas.
    const minL = 12;
    const maxL = 28;
    const L = Math.max(minL, Math.min(maxL, len));

    // End point of the arrow shaft
    const x2 = x + ux * L;
    const y2 = y - uy * L; // canvas y down

    // Draw the arrow shaft
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x2, y2);
    ctx.stroke();

    // Arrow head size scales with arrow length. Increase the head
    // proportions slightly to improve visibility on small arrows.
    // Increase arrow head size and relative proportions so that head remains
    // noticeable even for small arrows. The arrow head scales linearly with
    // length but is capped at a larger absolute size than before.
    const ah = Math.min(10, L * 0.4);
    const aw = ah * 0.6;
    const hx = x2, hy = y2;
    const px = -uy, py = ux;
    ctx.beginPath();
    ctx.moveTo(hx, hy);
    ctx.lineTo(hx - ux * ah + px * aw, hy + uy * ah - py * aw);
    ctx.lineTo(hx - ux * ah - px * aw, hy + uy * ah + py * aw);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function drawCharge(ctx, canvas, qpos){
    const p = w2c(canvas, qpos.x, qpos.y);
    ctx.save();
    ctx.fillStyle = "#ffffff";
    ctx.strokeStyle = "rgba(255,255,255,0.25)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(p.X, p.Y, 7, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  function drawProbe(ctx, canvas, probe){
    const p = w2c(canvas, probe.x, probe.y);
    ctx.save();
    ctx.fillStyle = "#61d67a";
    ctx.strokeStyle = "rgba(97,214,122,0.35)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(p.X, p.Y, 7, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  function drawBdot(ctx, x, y, Bz){
    // Out of page: + = ⊘, - = ⊗
    const col = getComputedStyle(document.documentElement).getPropertyValue('--orange').trim();
    ctx.save();
    // Increase font size for magnetic field dots even further to improve visibility
    ctx.font = "24px ui-monospace, Menlo, Consolas, monospace";
    ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillStyle = col;
    // Slightly higher opacity for better contrast
    ctx.globalAlpha = 0.95;
    // Use more standard EM symbols for into/out-of-plane magnetic field
    ctx.fillText(Bz >= 0 ? "⨀" : "⨂", x, y);
    ctx.restore();
  }

  let t0 = performance.now();
  function tick(now){
    const dt = (now - t0)/1000;
    t0 = now;

    const beta = parseFloat(betaEl.value);
    const betaObs = parseFloat(bObsEl.value);
    const density = parseInt(densEl.value, 10);
    const scale = parseFloat(scaleEl.value);

    betaTxt.textContent = beta.toFixed(2);
    bObsTxt.textContent = betaObs.toFixed(2);
    densTxt.textContent = density.toString();
    scaleTxt.textContent = scale.toFixed(2);

    // Move charge back and forth (simple loop) for intuition
    // Keep it within [-2.2, 2.2]
    const range = 2.2;
    if (!tick.qpos){
      tick.qpos = { x: -range, y: 0 };
      tick.dir = 1;
    }
    if (animEl.checked){
      // speed in world units per second scaled by |beta|
      const vWorld = (0.8 + 1.4*Math.abs(beta)) * tick.dir;
      tick.qpos.x += vWorld * dt;
      if (tick.qpos.x > range){ tick.qpos.x = range; tick.dir = -1; }
      if (tick.qpos.x < -range){ tick.qpos.x = -range; tick.dir = 1; }
    }
    const qpos = tick.qpos;

    // Clear canvases
    for (const [ctx, canvas] of [[ctxL,cLab],[ctxO,cObs]]){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if (showGridEl.checked) drawGrid(ctx, canvas);
    }

    // Sample grid and draw E vectors + B dots
    const W = cLab.width, H = cLab.height;
    const stepX = W / density;
    const stepY = H / Math.round(density*0.65);

    const blue = getComputedStyle(document.documentElement).getPropertyValue('--blue').trim();

    function drawPanel(ctx, canvas, mode){
      for(let Y=stepY/2; Y<H; Y+=stepY){
        for(let X=stepX/2; X<W; X+=stepX){
          const w = c2w(canvas, X, Y);
          const f = fieldsLabAtPoint(beta, qpos, w.x, w.y);

          let Ex=f.Ex, Ey=f.Ey, Bz=f.Bz;
          if (mode === "obs"){
            const fp = boostAlongX(betaObs, Ex, Ey, Bz);
            Ex = fp.Ex; Ey = fp.Ey; Bz = fp.Bz;
          }

          // Visual scaling (cap arrows)
          const magE = Math.hypot(Ex,Ey);
          // Visual scaling (cap arrows). Increase the scaling factor further and
          // reduce the denominator so that even small field magnitudes produce
          // longer arrows. This helps avoid vectors collapsing into points.
          const k = scale * 40 / (1 + 3 * magE);
          if (showEEl.checked){
            arrow(ctx, X, Y, Ex*k, Ey*k, blue);
          }
          if (showBEl.checked){
            // place B dots every other grid point to avoid clutter
            if (((Math.floor(X/stepX)+Math.floor(Y/stepY)) % 2) === 0){
              drawBdot(ctx, X, Y, Bz);
            }
          }
        }
      }

      drawCharge(ctx, canvas, qpos);
      drawProbe(ctx, canvas, probe);

      // Draw a local E arrow at probe for clarity
      const p = w2c(canvas, probe.x, probe.y);
      const f0 = fieldsLabAtPoint(beta, qpos, probe.x, probe.y);
      let Ex=f0.Ex, Ey=f0.Ey, Bz=f0.Bz;
      if (mode === "obs"){
        const fp = boostAlongX(betaObs, Ex, Ey, Bz);
        Ex=fp.Ex; Ey=fp.Ey; Bz=fp.Bz;
      }
      const magE = Math.hypot(Ex,Ey);
      // Scale factor for the probe arrow. Increase constants further and reduce the
      // denominator to make the probe arrow stand out and ensure small fields
      // remain visible.
      const k2 = scale * 100 / (1 + 3 * magE);
      if (showEEl.checked){
        arrow(ctx, p.X, p.Y, Ex*k2, Ey*k2, "#61d67a");
      }
      if (showBEl.checked){
        drawBdot(ctx, p.X+22, p.Y-18, Bz);
      }
    }

    drawPanel(ctxL, cLab, "lab");
    drawPanel(ctxO, cObs, "obs");

    // Readouts at probe
    const fLab = fieldsLabAtPoint(beta, qpos, probe.x, probe.y);
    const fObs = boostAlongX(betaObs, fLab.Ex, fLab.Ey, fLab.Bz);

    const EL = Math.hypot(fLab.Ex,fLab.Ey);
    const EO = Math.hypot(fObs.Ex,fObs.Ey);

    pTxt.textContent = `${probe.x.toFixed(2)}, ${probe.y.toFixed(2)}`;
    qTxt.textContent = `${qpos.x.toFixed(2)}, ${qpos.y.toFixed(2)}`;
    labTxt.textContent = `|E|=${EL.toFixed(3)}  Bz=${fLab.Bz.toFixed(3)}`;
    obsTxt.textContent = `|E'|=${EO.toFixed(3)}  Bz'=${fObs.Bz.toFixed(3)}`;

    // Update 3D arrows representing the fields at the probe. Only if 3D scene is initialized.
    if (scene3D && renderer3D) {
      // Convert field vectors into THREE vectors
      const scale3d = 0.8; // adjust this for arrow length scaling
      const eLabVec = new THREE.Vector3(fLab.Ex, fLab.Ey, 0);
      const bLabVec = new THREE.Vector3(0, 0, fLab.Bz);
      const eObsVec = new THREE.Vector3(fObs.Ex, fObs.Ey, 0);
      const bObsVec = new THREE.Vector3(0, 0, fObs.Bz);
      // Ensure non-zero direction to avoid NaNs when normalizing
      const safeVec = (vec) => {
        if (vec.length() < 1e-6) { return new THREE.Vector3(0, 0, 0.0001); }
        return vec;
      };
      // Helper to update an arrow given a vector
      const updateArrow = (arrow, vec) => {
        const v = safeVec(vec);
        arrow.setDirection(v.clone().normalize());
        arrow.setLength(v.length() * scale3d);
      };

      updateArrow(eLabArrow3D, eLabVec);
      // B arrows always point along ±z; their magnitude is |B_z|
      if (Math.abs(bLabVec.z) < 1e-6) {
        bLabArrow3D.setLength(0.001);
      } else {
        bLabArrow3D.setDirection(new THREE.Vector3(0, 0, Math.sign(bLabVec.z)));
        bLabArrow3D.setLength(Math.abs(bLabVec.z) * scale3d);
      }
      updateArrow(eObsArrow3D, eObsVec);
      if (Math.abs(bObsVec.z) < 1e-6) {
        bObsArrow3D.setLength(0.001);
      } else {
        bObsArrow3D.setDirection(new THREE.Vector3(0, 0, Math.sign(bObsVec.z)));
        bObsArrow3D.setLength(Math.abs(bObsVec.z) * scale3d);
      }
      controls3D.update();
      renderer3D.render(scene3D, camera3D);
    }

    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
